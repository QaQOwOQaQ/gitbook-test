{"./":{"url":"./","title":"Introduction","keywords":"","body":"C++ Prime ref about Linux 英文 curly brace：花括号，curly：弯曲 built-in type：内置类型 comment：注释 形参：parameter 实参：argument vim 快捷键 TODO p18 class p43 c++ 关键字，操作符替代名 在解释变量名的时候，遵循自右向左，数组自内而外，const就左原则（自左而右），从靠近变量名的部分开始 引用的本质 不能定义引用的引用 不能定义指向引用的指针 const的extern int x = int(5); 第一章 一个统计输入中每个连续值出现了多少次的函数 void wordCount() { int val = 0, cnt = 0; if(cin >> val) { // ! cnt = 1; int curVal; while(cin >> curVal) { if(curVal == val) cnt ++ ; else { cout 第二章 列表初始化不允许窄化转换，例如double转int 窄化转换： 浮点数转整数 整数转浮点数 高精度浮点数转低精度浮点数 大整数转小整数 注意编译器不一定会对窄化转换报错！ typedef 可以用逗号分割 #include typedef double *dp, d; // ! int main() { d x = 3.13; dp p = &x; } 关于引用 为什么 decltype((i)) 的返回类型是引用 一言以蔽之：(i) 的类型是 lvalue ref 再结合decltype的推到规则 decltype推导四规则 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&& 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T& 则，假设e的类型是T，则decltype（e）为T int main() { int i = 1; decltype((i)) x = i; (i) = 10; cout 为什么在class中不可以用圆括号初始化 参考 总结来说，就是避免语法分析时有歧义 为什么switch只能case整形 ref 因为switch内部实现是一个跳转表，跳转表就是一个数组，这个数组的大小就是[switch的最大case-最小case+1]，可见这个数组并不一定充分利用，因为中间可能空出很多case。 对于case，我们得到case值，减去最小case，得到的就是在跳转表中的下标。对于一个下标，我们只能通过整形去求。 为何C++/Rust都不允许静态函数是虚的？ 你的定义不够精确。否则的话你自己就能发现问题。 这个函数是要运行时查找具体的入口地址再调用的 其实应该是这个函数x是要运行时查找所在对象具体的入口地址再调用的。或者说，虚函数表是从所在对象索引的。 而static不存在所在对象。所以怎么找它的虚函数表？别忘了在加入static之前，你需要调用一个静态函数，得这样： static_cast(0)->Func(); 因为Func和对象无关，所以这里搞个0也无所谓。后来有了静态函数，你可以写成： T::Func(); 所以，你这下明白了为什么虚函数表不能放静态函数了吧。 你非得要类似功能的话，不用static就行了呗，就把那个函数变成一个成员。那就随便virtual了。 总结来说，静态函数是不属于class的实例的，也就是说，静态函数不属于某个具体的对象。但是虚函数是依赖于对象的，因为它要从对象的虚函数表中查找具体的入口（到底是那个函数) 三种继承方式 C++ 中支持三种继承方式：公有继承，私有继承，保护继承，C++ 中的默认访问属性为 private 公有继承（public） 基类的 public 和 protected 成员的访问属性在派生类中保持不变，但基类的 private 成员不可直接访问。 派生类中的成员函数可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员。 通过派生类的对象只能访问基类的 public 成员。 保护继承（protected） 基类的 public 和 protected 成员都以 protected 身份出现在派生类中，但基类的 private 成员不可直接访问。 派生类中的成员函数可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员。 通过派生类的对象不能直接访问基类中的任何成员 私有继承（private） 基类的 public 和 protected 成员都以 private 身份出现在派生类中，但基类的 private 成员不可直接访问。 派生类中的成员函数可以直接访问基类中的 public 和 protected 成员，但不能直接访问基类的 private 成员。 通过派生类的对象不能直接访问基类中的任何成员 用自定义类型 set #include #include #include #include #include #include #include using namespace std; // 1. 重载 operator rhs.val; } int get() const { return val; } }; void testFoo() { set s; for(int i = 0; i s(cmpBar); for(int i = 0; i 起别名 #include #include #include #include #include #include #include #include #include using namespace std; class Foo { private: int val; public: Foo(int _val) : val(_val) {} int get() const { return val; } }; bool cmp(const Foo &l, const Foo &r) { return l.get() q0(cmp); // 函数指针 + decltype bool(*p)(const Foo&, const Foo&) = cmp; set q1(cmp); // using 别名 using T = bool(*)(const Foo&, const Foo&); set q2(cmp); // typedef 别名 typedef bool(*cmpFoo)(const Foo&, const Foo&); set q3(cmp); return 0; } priority_queue，和set几乎一模一样，不同之处在于需要在声明时添加“底层容器”，因为优先队列是一个适配器。 #include #include #include #include #include #include #include #include #include using namespace std; class Foo { private: int val; public: Foo(int _val) : val(_val) {} int get() const { return val; } }; bool cmp(const Foo &l, const Foo &r) { return l.get() // decltype，注意decltype一个函数得到的是引用而不是指针 priority_queue, decltype(cmp)*> q0(cmp); // 函数指针 + decltype bool(*p)(const Foo&, const Foo&) = cmp; priority_queue, decltype(p)> q1(cmp); // using 别名 using T = bool(*)(const Foo&, const Foo&); priority_queue, T> q2(cmp); // typedef 别名 typedef bool(*cmpFoo)(const Foo&, const Foo&); priority_queue, cmpFoo> q3(cmp); return 0; } 错误处理函数 perror strerror #include void perror(const char *s); 它先打印s指向的字符串，然後輸出當前errno值所對應的錯誤提示信息，例如當前errno若為12，調用perror(\"ABC\")，會輸出\"ABC: Cannot allocate memory\"。 #include char *strerror(int errnum); 它返回errnum的值所對應的錯誤提示信息，例如errnum等於12的話，它就會返回\"Cannot allocate memory\"。 参考 errno 将errno 的值解释为错误消息，并将其打印到stderr（标准错误输出流，通常是控制台），可选择在其前面加上str中指定的自定义消息。 errno是一个整型变量，其值描述错误条件或调用库函数产生的诊断信息（C 标准库的任何函数都可以为 errno 设置一个值，即使没有在本参考中明确指定，即使没有发生错误），请参阅errno了解更多信息 定义指针要记得初始化 int *p; if(p == nullptr) cout 这是因为p没有初始化，它里面的内容是未知的，因此对 它的行为是未定义的 所以我们应该写为：int *p = nullptr; 纯虚函数 当一个 class 包含纯虚函数时，它就是一个抽象类，我们不可以为一个抽象类创建实例，但是我们可以为这个虚函数提供定义，并且还可以调用它。 [Effective c++ 条款35] #include #include #include using namespace std; class B { public: virtual void f() = 0; }; void B::f() { cout 函数指针别名 int f(int a, int b) { return a + b; } using prt1 = int(*)(int,int); typedef int(ptr2*)(int,int); 返回值类型不需要加括号 std::function 由于可调用对象的定义方式比较多，但是函数的调用方式较为类似，因此需要使用一个统一的方式保存可调用对象或者传递可调用对象。于是，std::function就诞生了。 std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。 我们通常把{函数，函数指针，lambda表达式，仿函数}称为可调用对象，function可以持有任何与它的签名式“兼容”的可调用对象。所谓兼容，就是说这个可调用对象的参数可以隐式转换为function签名式中的对象。 #include #include #include #include using namespace std; typedef function func; // int double f(double a, double b) // double { return a * b; } struct Foo { int operator()(short a, short b) { return a - b; } }; int main() { int a = 2, b = 4; func p1 = f; func p2 = Foo(); cout function 相当于一个指向函数的泛化指针 "},"message/1.html":{"url":"message/1.html","title":"基本安装","keywords":"","body":"111111111111 "},"message/2.html":{"url":"message/2.html","title":"Node.js安装","keywords":"","body":"2222222222 "},"output/1.html":{"url":"output/1.html","title":"图书编辑","keywords":"","body":"11111111111111111111 hello "},"output/2.html":{"url":"output/2.html","title":"gitbook命令行&markdown编辑","keywords":"","body":"22222222222222222 sdfasdfsdfdsf "},"output/3.html":{"url":"output/3.html","title":"gitbook editor编辑","keywords":"","body":"333333333333333333333 4445 "}}